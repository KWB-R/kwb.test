# create_test_files ------------------------------------------------------------

#' Create Test Files
#'
#' Create test files for each source file containing one
#'   \code{\link[testthat]{test_that}} call for each function in the package
#'
#' Existing test files will not be overwritten.
#'
#' @param package_dir path to package directory in which to create the test
#'   files
#' @param dbg if \code{TRUE}, debug messages are shown
#'
#' @export
#'
create_test_files <- function(package_dir = getwd(), dbg = TRUE)
{
  package_name <- basename(package_dir)

  old_dir <- setwd(package_dir)

  on.exit(setwd(old_dir))

  usethis::use_testthat()

  source_files <- file.path("R", dir("R"))

  test_dir <- file.path("tests", "testthat")

  test_dir <- kwb.utils::createDirectory(test_dir, dbg = dbg)

  #source_file <- source_files[1]

  for (source_file in source_files) {

    test_file <- file.path(test_dir, sprintf("test-%s", basename(source_file)))

    if (file.exists(test_file)) {

      message("Skipping exising file ", basename(test_file))

    } else {

      test_codes <- get_test_codes_for_functions_in_file(source_file, package_name)

      intro <- kwb.utils::resolve("intro", get_templates())

      test_code <- c(intro, do.call(c, test_codes))

      kwb.utils::catIf(dbg, "Writing", test_file, "... ")

      writeLines(test_code, test_file)

      kwb.utils::catIf(dbg, "ok.\n")
    }
  }
}

# get_test_codes_for_functions_in_file -----------------------------------------
get_test_codes_for_functions_in_file <- function(file, package_name)
{
  lapply(
    get_function_assignments(file),
    FUN = get_test_for_function_assignment,
    package_name = package_name,
    exports = getNamespaceExports(package_name)
  )
}

# get_function_assignments -----------------------------------------------------
get_function_assignments <- function(file)
{
  code <- as.list(parse(file))

  #expr <- code[[2]]

  is_function_assignment <- sapply(code, function(expr) {
    ok <- as.character(expr[[1]]) == "<-"
    ok && length(expr) >= 3 && as.character(expr[[3]][[1]]) == "function"
  })

  code[is_function_assignment]
}

# get_test_for_function_assignment ---------------------------------------------
get_test_for_function_assignment <- function(assignment, package_name, exports)
{
  function_name <- as.character(assignment[[2]])

  exported <- function_name %in% exports

  error <- ! runs_without_arguments(package_name, function_name)

  templates <- kwb.utils::resolve(
    get_templates(),
    fun = function_name,
    pkg = package_name,
    args = "",
    pkg_fun = ifelse(exported, "<pkg_fun_exported>", "<pkg_fun_private>"),
    test_that_body = ifelse(error, "<fun_call_error>", "<fun_call_alone>")
  )

  templates$test_that_call
}

# get_templates ----------------------------------------------------------------
get_templates <- function()
{
  list(
    intro = "#\n# This test file has been generated by <test_creator>\n#\n",
    test_creator = "kwb.test::createTestFiles()",
    test_that_call = "test_that(\"<fun>() works\", {\n\n<test_that_body>})\n",
    fun_call = "<pkg_fun>(<args>)",
    fun_call_alone = "  <fun_call>\n",
    fun_call_error = "  expect_error(<fun_call>)\n",
    fun_call_message = "  expect_message(<fun_call>)\n",
    fun_call_silent = "  expect_silent(<fun_call>)\n,",
    pkg_fun_exported = "<fun>",
    pkg_fun_private = "<pkg>:::<fun>"
  )
}

# runs_without_arguments -------------------------------------------------------
runs_without_arguments <- function(package_name, function_name)
{
  expr <- parse(text = sprintf("%s:::%s()", package_name, function_name))

  ! inherits(tryCatch(eval(expr), error = function(e) e), "simpleError")
}
